* Overview
  This is my attempt at "the matasano crypto challenges" at
  cryptopals.com

* Set 1
** Convert hex to base64
*** 2015-11-01
    Base64 uses 6 bits, vs normal hex (Base16) which uses 4. Need to
    convert bytes (8 bits, Base256) to 6 bit words. Best conversion is
    24 bits which is 3x8 and 4x6.

*** 2015-11-02
    Break byte array into hexlets.
    Next: need to refactor convert-hexlet!
    Saw an interesting way to manage the Base64code. Make an array of
    all characters

*** 2015-11-03
    Use partition function to split string into 3 byte groups. Then pad
    the tuples(?) with "0"s. I tried the following code, but removed
    it in preference for another version:
    #+BEGIN_SRC clojure
   (defn hex-3split
  [[b1 b2 b3]]
  (let [x (bit-or
           (bit-shift-left (int b1) 16)
           (bit-shift-left (int b2) 8)
           (bit-shift-left (int b3) 0))]
    [(unsigned-bit-shift-right x 18)
     (bit-and (unsigned-bit-shift-right x 12) 0x3f)
     (bit-and (unsigned-bit-shift-right x 6) 0x3f)
     (bit-and x 0x3f)]))
    #+END_SRC

*** 2015-11-04
    Think I've got base64-encode working. I'm now starting on base16
    decode.
    I've used a Java string conversion routine for hex conversion. I
    got set 1 test to pass!


** Fixed XOR
***   2015-11-04
      Started and finished. Just needed to add a formatting encode-base16 as
      well.

** Single-byte XOR cipher
***   2015-11-04
    Interesting! Need to break a cipher. Suggested to use character
    frequency, so need to look that up...
    Letter frequency table came from:
    http://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html
    My idea to score the result text is:
1. calculate score for each letter in text
2. calcualte relative score for each letter
3. calculate absolute difference in relative score for each letter (between
   known frequency and text)
4. sum difference
5. smallest difference wins

*** 2015-11-05
    Looking for a way to convert between string and keyword in
    clojure. Found "keyword", but not sure it's what I want.
    Another way to solve this might be to iterate over list and filter on
    each item in the iteration. This means at most 26ish repetitions (not
    sure about digits).
    Created function to count occurences of characters in a string and
    return character and count in map.

*** 2015-11-06
    Got word-score working. It can be a generic function that compares
    two maps, comparing the second value of each map.
    I hacked a bit of a pay around to try and get the algorithm. CAN'T
    LEAVE IT LIKE THIS!
*** 2015-11-07
    I've seen the code decrypted, but my frequency algorithm is not
    quite working correctly. It may be that I'm not creating a
    distribution of the code letters, and am just comparing absoute
    counts. Also, not sure how to account for punctuation in frequency
    distribution.
    Cleaning up some of the earlier code. Especially the base64
    decode.
*** <2015-11-08>
    + Detour - play around with concept of tranducers. Started
      watching R.Hickey talk on this. Recommends "Lectures on
      Constructive Functional Programming" by R.S
      Bird. http://www.cs.ox.ac.uk/files/3390/PRG69.pdf and A tutorial
      on the universality and expressiveness of fold by GRAHAM HUTTON
      -- http://www.cs.nott.ac.uk/~gmh/fold.pdf
    + I've just commited change with commented old functions. I will
      now remove these, and just leave transducers.
    + I was really sick of the encode-byte routine. So I ran it, and
      copied the output directly in. Much cleaner. For reference the
      original was:
      #+BEGIN_SRC clojure
        (defn encode-byte-base64
          [b]
          (let [crs [[\A \Z] [\a \z] [\0 \9]]
                rfn (fn [[a b]] (range (byte a) (inc (byte b))))
                rconj (fn [x y m] (conj (vec  m) x y))]
            (nth (->>
                  crs
                  (map rfn)
                  (rconj \+ \/)
                  flatten
                  (map char)) b)))
      #+END_SRC
      + Found function "frequencies" which counts distinct occurences
        of items in sequence. Replaced Count-occurences. Previous code
        was:
      #+BEGIN_SRC clojure
        (defn count-occurences
          [m l]
          (let [h (first l)
                f (fn [a] (= h a))]
            (cond
              (some? h) (count-occurences
                         (assoc m h (count (filter f l)))
                         (remove f l))
              :else m)))

        (deftest test-count-occurences
          (testing "test count-occurence"
            (are [x y] (= x (count-occurences {} y))
              {\a 1} "a"
              {\a 5} "aaaaa"
              {} ""
              {\a 3 \b 3} "ababab")))
      #+END_SRC
*** <2015-11-09>
    + I need to create a function that will diff two maps. Should
      return either a map, or a sequence of differences.
      1. Use the input map as base
      2. for each key, output a new key that is value - value of same
         key in reference map
      3. If reference map does not have the key, then assume the
         referene map has 0 as the value.
    + I've found the merge-with function. this is perfect for my
      needs. It takes two maps, and merges them while applying a
      function.
*** <2015-11-10>
    + Finding it hard to create a test for the XOR word
      function. There's definately something wrong with my scoring
      function. I'm just not sure what. Why is everything scoring
      9.9172..?
*** <2015-11-11>
    + I think i've got character conversion issues. Not sure how my
      tests haven't picked this up. I'll have to review, and find
      why. Still not getting a good word score!
    + Finally got it working. Was a mix of dealing with special
      characters correctly and a good comparison function. Trick was
      to remove whitespace, but leave non-letters.This penalises
      non-letters but ignore whitespace. Also, comparison function is
      divide. This works better than - gives a better differentiator.
    + Code needs a clean-up. Maybe some more tests too?? Definately a
      clean up.
    + Anyway, challenge complete!
** Detect single-character XOR
*** <2015-11-12>
    + Probably the main steps for this challenge are:
      - Slurp file
      - For each line in file find the decode-byte and word score
      - Return the line, byte and score for every line
      - Take the line with the maximum score
    + Did a bit of clean-up
